## Лабораторная работа #3. Почти 2-3 дерево.
### Обязательная задача
Задача состоит в реализации функций для работы с упрощённой версией 2-3 дерева, которая допускает несбалансированность.
Таким образом, вставка в такое дерево будет схожа со вставкой в бинарное дерево поиска.
Если при вставке в дерево листом оказался 2-узел, то его необходимо поменять на 3-узел.
В противном случае добавляем ребёнка (2-узел) к 3-узлу.

Для представления узлов дерева используется структура
```
enum {
    node_2,
    node_3,
} node_type;

struct node_23 {
    struct node_23 *parent;
    struct node_23 *left;
    struct node_23 *middle;
    struct node_23 *right;
    int value_left;
    int value_right;
    node_type type;
};
```
Тип узла хранится в поле `type`.
Если узел является 2-узлом, то поля `middle` и `value_right` не определены.

Необходимо реализовать следующие функции:
- `void print(const node_23 *tree, char* result)` — функция выводит в массив `result` значения чисел, хранящихся в дереве, в порядке их возрастания через пробел.
В последний элемент массива необходимо положить нулевой байт, чтобы `result` стал корректной null-terminated строкой, пригодной для вывода через `printf`.
- `const node_23 *find(const node_23 *tree, int value)` — функция которая возвращает узел дерева, содержащий необходимый узел (любой из узлов, если число не уникально).
- `node_23 *add(node_23 *tree, int value)` — функция вставки в дерево нового значения.
Если в процессе вставки меняется корневой узел, то функция возвращает новый корень.
- `int_pair get_shortest_longest_path(const node_23 *tree)` — функция возвращает структуру, содержащую длину самого короткого пути из корня в узел и самого длинного, соответственно.
Высота дерева из одного узла считается равной нулю, а значит длины обоих путей равны нулю.
- `void get_nodes_with_key_between(const node_23 *tree, int key_min, int key_max, node_23* res)` — функция поиска узлов дерева со значениями из полуинтервала `[key_min, key_max)`.
Если 3-узел дерева содержит значения, одного из которых попадает в интервал, а второе нет, то дерева должно попасть в результат поиска.
Результат поиска кладётся в массив `res`, который инициализирован `NULL`-ами.
Узлы должны быть положены в массив в порядке возрастания значений узлов.
Предполагается, что длины массива достаточно для любых вызовов функции.

### Задача для энтузиастов за дополнительные баллы
Реализовать функцию `node_23 *add(node_23 *tree, int value)` так, чтобы дерево оставалось сбалансированным (каким и должно быть 2-3 дерево).
Таким образом, функция `get_shortest_longest_path` должна всегда возвращать одинаковые значения длинного и короткого путей.
